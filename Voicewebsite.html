<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Voice Terminal Emulator</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      background: linear-gradient(135deg, #0a0e27 0%, #1a1a2e 100%);
      color: #00ff41;
      font-family: 'Courier New', monospace;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      padding: 20px;
    }
    
    #terminal-container {
      background: rgba(10, 14, 39, 0.95);
      width: 100%;
      max-width: 900px;
      border: 2px solid #00ff41;
      border-radius: 8px;
      box-shadow: 0 0 30px rgba(0, 255, 65, 0.3), inset 0 0 100px rgba(0, 255, 65, 0.05);
      overflow: hidden;
    }
    
    #terminal-header {
      background: linear-gradient(180deg, #00ff41 0%, #00cc33 100%);
      color: #0a0e27;
      padding: 10px 15px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: bold;
    }
    
    #status {
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #0a0e27;
      animation: pulse 2s ease-in-out infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }
    
    #terminal {
      padding: 20px;
      height: 500px;
      overflow-y: auto;
      background: rgba(0, 0, 0, 0.3);
    }
    
    #terminal::-webkit-scrollbar {
      width: 8px;
    }
    
    #terminal::-webkit-scrollbar-track {
      background: rgba(0, 255, 65, 0.1);
    }
    
    #terminal::-webkit-scrollbar-thumb {
      background: #00ff41;
      border-radius: 4px;
    }
    
    #output {
      margin-bottom: 15px;
    }
    
    .output-line {
      margin: 3px 0;
      line-height: 1.5;
      animation: fadeIn 0.3s ease-in;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateX(-10px); }
      to { opacity: 1; transform: translateX(0); }
    }
    
    .prompt-line {
      color: #00ccff;
    }
    
    .error {
      color: #ff4444;
    }
    
    .success {
      color: #00ff88;
    }
    
    #input-line {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    #prompt {
      color: #00ccff;
      white-space: nowrap;
    }
    
    #command-input {
      background: transparent;
      border: none;
      color: #00ff41;
      font-family: 'Courier New', monospace;
      font-size: 16px;
      outline: none;
      flex-grow: 1;
      caret-color: #00ff41;
    }
    
    #controls {
      display: flex;
      gap: 5px;
    }
    
    .btn {
      background: rgba(0, 255, 65, 0.1);
      color: #00ff41;
      border: 1px solid #00ff41;
      padding: 6px 12px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      border-radius: 4px;
      transition: all 0.3s ease;
    }
    
    .btn:hover {
      background: rgba(0, 255, 65, 0.2);
      box-shadow: 0 0 10px rgba(0, 255, 65, 0.5);
    }
    
    .btn:active {
      transform: scale(0.95);
    }
    
    #voice-btn.recording {
      background: rgba(255, 68, 68, 0.2);
      border-color: #ff4444;
      color: #ff4444;
      animation: recordPulse 1s ease-in-out infinite;
    }
    
    @keyframes recordPulse {
      0%, 100% { box-shadow: 0 0 5px rgba(255, 68, 68, 0.5); }
      50% { box-shadow: 0 0 20px rgba(255, 68, 68, 0.8); }
    }
    
    .listening {
      color: #ffaa00;
      font-style: italic;
    }
  </style>
</head>
<body>
  <div id="terminal-container">
    <div id="terminal-header">
      <span>VOICE TERMINAL v2.0</span>
      <div id="status">
        <span class="status-dot"></span>
        <span id="status-text">READY</span>
      </div>
    </div>
    <div id="terminal">
      <div id="output"></div>
      <div id="input-line">
        <span id="prompt">user@vterm:~$</span>
        <input type="text" id="command-input" autofocus>
        <div id="controls">
          <button class="btn" id="voice-btn" title="Voice Input (Click to start/stop)">üé§</button>
          <button class="btn" id="speak-btn" title="Toggle Speech Output">üîä</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // File System
    let fileSystem = {
      'home': {
        'user': {
          'welcome.txt': 'Welcome to Voice Terminal!\n\nTry these commands:\n- help\n- ls\n- cat welcome.txt\n- mkdir test\n- echo hello > test.txt',
          'projects': {},
          'notes.txt': 'Remember to back up your data!'
        }
      },
      'etc': {
        'config.txt': 'VOICE_ENABLED=true\nTHEME=matrix'
      }
    };
    
    let currentPath = ['home', 'user'];
    let commandHistory = [];
    let historyIndex = -1;
    let speechEnabled = true;
    
    // DOM Elements
    const outputDiv = document.getElementById('output');
    const input = document.getElementById('command-input');
    const voiceBtn = document.getElementById('voice-btn');
    const speakBtn = document.getElementById('speak-btn');
    const statusText = document.getElementById('status-text');
    const promptSpan = document.getElementById('prompt');
    
    // Speech Recognition
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    const recognition = SpeechRecognition ? new SpeechRecognition() : null;
    const synthesis = window.speechSynthesis;
    
    if (recognition) {
      recognition.continuous = false;
      recognition.interimResults = false;
      
      recognition.onstart = () => {
        voiceBtn.classList.add('recording');
        statusText.textContent = 'LISTENING...';
        addOutput('üé§ Listening...', 'listening');
      };
      
      recognition.onresult = (e) => {
        const transcript = e.results[0][0].transcript;
        input.value = transcript;
        addOutput(`user@vterm:~$ ${transcript}`, 'prompt-line');
        executeCommand(transcript);
      };
      
      recognition.onerror = (e) => {
        addOutput(`Voice error: ${e.error}`, 'error');
        statusText.textContent = 'ERROR';
      };
      
      recognition.onend = () => {
        voiceBtn.classList.remove('recording');
        statusText.textContent = 'READY';
      };
    }
    
    // Event Listeners
    voiceBtn.addEventListener('click', async () => {
      if (!recognition) {
        addOutput('Speech recognition not supported in this browser', 'error');
        addOutput('Try Chrome, Edge, or Safari for voice support', 'error');
        speak('Speech recognition not supported');
        return;
      }
      
      if (voiceBtn.classList.contains('recording')) {
        recognition.stop();
      } else {
        try {
          // Request microphone permission first
          await navigator.mediaDevices.getUserMedia({ audio: true });
          recognition.start();
        } catch (err) {
          addOutput('Microphone access denied or not available', 'error');
          addOutput('Please allow microphone access in browser settings', 'error');
          addOutput(`Error: ${err.message}`, 'error');
          statusText.textContent = 'MIC BLOCKED';
        }
      }
    });
    
    speakBtn.addEventListener('click', () => {
      speechEnabled = !speechEnabled;
      speakBtn.textContent = speechEnabled ? 'üîä' : 'üîá';
      const msg = speechEnabled ? 'Speech enabled' : 'Speech disabled';
      addOutput(msg, 'success');
      if (speechEnabled) speak(msg);
    });
    
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        const cmd = input.value.trim();
        if (cmd) {
          addOutput(`user@vterm:~$ ${cmd}`, 'prompt-line');
          commandHistory.push(cmd);
          historyIndex = commandHistory.length;
          executeCommand(cmd);
          input.value = '';
        }
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        if (historyIndex > 0) {
          historyIndex--;
          input.value = commandHistory[historyIndex];
        }
      } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        if (historyIndex < commandHistory.length - 1) {
          historyIndex++;
          input.value = commandHistory[historyIndex];
        } else {
          historyIndex = commandHistory.length;
          input.value = '';
        }
      }
    });
    
    // Command Execution
    function executeCommand(cmdText) {
      // Clean up the command text (remove trailing punctuation from voice input)
      const cleanText = cmdText.trim().replace(/[.,!?;:]+$/g, '');
      const parts = cleanText.split(/\s+/);
      const cmd = parts[0].toLowerCase();
      const args = parts.slice(1);
      
      let output = '';
      
      switch(cmd) {
        case 'help':
          output = `Available commands:
  ls              - List directory contents
  cd <dir>        - Change directory
  pwd             - Print working directory
  cat <file>      - Display file contents
  mkdir <dir>     - Create directory
  touch <file>    - Create empty file
  echo <text>     - Display text or write to file (use > filename)
  rm <file>       - Remove file
  clear           - Clear terminal
  whoami          - Display current user
  date            - Show current date/time
  help            - Show this help message`;
          break;
          
        case 'ls':
          const dir = getCurrentDir();
          if (dir && typeof dir === 'object') {
            const items = Object.keys(dir);
            output = items.length > 0 ? items.join('  ') : '(empty directory)';
          } else {
            output = 'Not a directory';
          }
          break;
          
        case 'pwd':
          output = '/' + currentPath.join('/');
          break;
          
        case 'cd':
          if (args.length === 0) {
            currentPath = ['home', 'user'];
            output = 'Changed to home directory';
          } else if (args[0] === '..') {
            if (currentPath.length > 0) {
              currentPath.pop();
              output = 'Changed to parent directory';
            } else {
              output = 'Already at root';
            }
          } else if (args[0] === '/') {
            currentPath = [];
            output = 'Changed to root';
          } else {
            const dir = getCurrentDir();
            if (dir && dir[args[0]] && typeof dir[args[0]] === 'object') {
              currentPath.push(args[0]);
              output = `Changed to ${args[0]}`;
            } else {
              output = `cd: ${args[0]}: No such directory`;
            }
          }
          updatePrompt();
          break;
          
        case 'cat':
          if (args.length === 0) {
            output = 'cat: missing file operand';
          } else {
            const dir = getCurrentDir();
            if (dir && typeof dir[args[0]] === 'string') {
              output = dir[args[0]];
            } else {
              output = `cat: ${args[0]}: No such file`;
            }
          }
          break;
          
        case 'mkdir':
          if (args.length === 0) {
            output = 'mkdir: missing operand';
          } else {
            const dir = getCurrentDir();
            if (dir) {
              if (!dir[args[0]]) {
                dir[args[0]] = {};
                output = `Directory '${args[0]}' created`;
              } else {
                output = `mkdir: ${args[0]}: File exists`;
              }
            }
          }
          break;
          
        case 'touch':
          if (args.length === 0) {
            output = 'touch: missing file operand';
          } else {
            const dir = getCurrentDir();
            if (dir) {
              dir[args[0]] = '';
              output = `File '${args[0]}' created`;
            }
          }
          break;
          
        case 'echo':
          const echoText = args.join(' ');
          const redirectMatch = echoText.match(/(.+?)\s*>\s*(.+)/);
          if (redirectMatch) {
            const content = redirectMatch[1].trim();
            const filename = redirectMatch[2].trim();
            const dir = getCurrentDir();
            if (dir) {
              dir[filename] = content;
              output = `Written to ${filename}`;
            }
          } else {
            output = echoText;
          }
          break;
          
        case 'rm':
          if (args.length === 0) {
            output = 'rm: missing operand';
          } else {
            const dir = getCurrentDir();
            if (dir && dir[args[0]]) {
              delete dir[args[0]];
              output = `Removed '${args[0]}'`;
            } else {
              output = `rm: ${args[0]}: No such file`;
            }
          }
          break;
          
        case 'clear':
          outputDiv.innerHTML = '';
          return;
          
        case 'whoami':
          output = 'user';
          break;
          
        case 'date':
          output = new Date().toString();
          break;
          
        default:
          output = `${cmd}: command not found. Type 'help' for available commands.`;
      }
      
      if (output) {
        const isError = output.includes('not found') || output.includes('No such') || output.includes('error');
        addOutput(output, isError ? 'error' : '');
        if (speechEnabled && output.length < 200) {
          speak(output);
        }
      }
    }
    
    // Helper Functions
    function getCurrentDir() {
      let dir = fileSystem;
      for (const part of currentPath) {
        if (dir && typeof dir === 'object') {
          dir = dir[part];
        } else {
          return null;
        }
      }
      return dir;
    }
    
    function updatePrompt() {
      const path = currentPath.length > 0 ? currentPath[currentPath.length - 1] : 'root';
      promptSpan.textContent = `user@vterm:${path}$`;
    }
    
    function addOutput(text, className = '') {
      const lines = text.split('\n');
      lines.forEach(line => {
        const div = document.createElement('div');
        div.className = `output-line ${className}`;
        div.textContent = line;
        outputDiv.appendChild(div);
      });
      outputDiv.scrollTop = outputDiv.scrollHeight;
    }
    
    function speak(text) {
      if (!speechEnabled || !synthesis) return;
      synthesis.cancel();
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.rate = 1.1;
      utterance.pitch = 1.0;
      synthesis.speak(utterance);
    }
    
    // Initialize
    addOutput('='.repeat(60), 'success');
    addOutput('VOICE TERMINAL SYSTEM v2.0', 'success');
    addOutput('='.repeat(60), 'success');
    addOutput('');
    addOutput('Type "help" for commands or click üé§ to speak');
    addOutput('');
    
    if (!recognition) {
      addOutput('‚ö†Ô∏è  Voice input not supported in this browser', 'error');
    }
    
    speak('Voice terminal ready');
  </script>
</body>
</html>